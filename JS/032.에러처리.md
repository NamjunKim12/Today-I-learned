## 📌 에러 처리의 필요성

- 에러가 발생하지 않는 프로그램은 없음.
- 따라서 우리가 작성한 코드에서는 에러가 발생할 가능성을 항상 염두에 두고, 이에 대응하는 코드를 작성해야함.

### 📌 try...catch...finally 문

- `try...catch...finally` 문은 에러가 발생할 가능성이 있는 문장들을 `try` 블록에 기술하고, 에러 발생시 처리할 문장들을 `catch` 블록에 기술함.

```js
try {
  // 에러가 발생할 가능성이 있는 코드
} catch (error) {
  // 에러 발생시 처리할 문들
} finally {
  // try 블록의 실행이 종료되면 결과에 상관없이 언제나 한 번 실행됨.
}
```

- `try` 블록의 코드가 실행되는 도중 에러가 발생하면, `try` 블록의 실행을 즉시 중단하고 `catch` 블록의 코드가 실행됨.
- `catch`문의 error 변수는 에러가 발생되면 생성되고 catch블록에서만 코드가 유효함. 
- async/await 문에서는 `try...catch` 문을 통해 에러를 처리해주는 것이 좋음.

### 📌 에러 객체

- `Error` 생성자 함수는 에러 객체를 생성함. `Error` 생성자 함수에는 에러 메시지를 인수로 전달할 수 있음.

```js
const error = new Error('invalid email');
```
- 에러 객체는 `stack`과 `message` 프로퍼티를 갖고 있음. stack 프로퍼티는 에러를 발생시킨 실행 컨텍스트 스택의 호출 정보를 나타내고, message 프로퍼티의 값은 Error 생성자 함수에 인수로 전달한 에러 메시지임. 
- 자바스크립트는 Error 생성자 함수 이외에도 7가지의 에러 객체를 생성할 수 있는 생성자 함수를 제공함.
- `EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`, `TypeError`, `URIError`, `AggregateError` 등이 있으며, 모두 `Error` 생성자 함수의 프로토타입을 상속 받음.


### 📌 throw 문

- Error 객체를 생성자 함수를 통해 생성한다고 해서, 에러가 발생하는 것이 아님. 에러 객체 생성과 에러 발생은 의미가 다름. 
- 에러가 발생하려면 `throw` 문을 사용해야함. `throw` 문은 에러 객체를 던져 에러를 발생시킴.

```js
throw new Error('invalid email');
```

### 📌 에러의 전파

- 에러는 **함수 호출 단위로 전파됨**. 즉, 함수 내부에서 처리하지 않은 에러는 함수를 호출한 상위 코드에서 처리함.
- 비동기 함수인 setTimeout이나 프로미스 후속처리 메서드는 호출자가 **이미 콜스택에 존재하지 않는 상태에서 실행되므로 에러를 캐치할 수 없음.** 따라서 비동기 함수 내부에서 에러가 발생하면 콜스택의 최상위 코드까지 에러가 전파되어 논리적인 오류를 야기함.
